<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Designer - Native Optimized</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5e6d3 0%, #e8d5c4 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* Performance Monitor */
        .performance-monitor {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 1000;
        }

        /* Bottom Control Bar */
        .bottom-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        .control-btn {
            width: 45px;
            height: 45px;
            border: none;
            background: rgba(245, 230, 211, 0.8);
            color: #8b6f47;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: rgba(245, 230, 211, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .control-btn:active {
            background: rgba(245, 230, 211, 0.9);
        }

        .control-btn.active {
            background: #8b6f47;
            color: white;
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8b6f47;
            font-size: 18px;
            text-align: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(139, 111, 71, 0.3);
            border-top: 3px solid #8b6f47;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Furniture Menu */
        .furniture-menu {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 10px;
            z-index: 1000;
        }

        .furniture-item {
            width: 60px;
            height: 60px;
            margin: 5px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: rgba(245, 230, 211, 0.8);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
        }

        .furniture-item:hover {
            border-color: #8b6f47;
            background: rgba(245, 230, 211, 1);
        }

        .furniture-item.selected {
            border-color: #8b6f47;
            background: #8b6f47;
            color: white;
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <div>Loading 3D Scene...</div>
    </div>

    <!-- Performance Monitor -->
    <div id="performance" class="performance-monitor">
        <div>FPS: <span id="fps">0</span></div>
        <div>Draw Calls: <span id="drawCalls">0</span></div>
        <div>Triangles: <span id="triangles">0</span></div>
        <div>Memory: <span id="memory">0MB</span></div>
    </div>

    <!-- Furniture Menu -->
    <div id="furnitureMenu" class="furniture-menu">
        <div class="furniture-item" data-type="desk" title="Desk">üè¢</div>
        <div class="furniture-item" data-type="chair" title="Chair">ü™ë</div>
        <div class="furniture-item" data-type="bookshelf" title="Bookshelf">üìö</div>
        <div class="furniture-item" data-type="plant" title="Plant">ü™¥</div>
        <div class="furniture-item" data-type="lamp" title="Lamp">üí°</div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Bottom Controls -->
    <div class="bottom-controls">
        <button class="control-btn" id="resetView" title="Reset View">üè†</button>
        <button class="control-btn" id="deleteMode" title="Delete Mode">üóëÔ∏è</button>
        <button class="control-btn" id="colorMode" title="Color Mode">üé®</button>
        <button class="control-btn" id="settingsMode" title="Settings">‚öôÔ∏è</button>
    </div>

    <script src="three.min.js"></script>
    <script>
        class RoomDesigner {
            constructor() {
                // Wait for Three.js to load
                if (typeof THREE === 'undefined') {
                    console.error('Three.js not loaded');
                    return;
                }
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.objects = new Map();
                this.selectedObject = null;
                this.isPlacingObject = false;
                this.placingType = null;
                this.isDragging = false;
                this.deleteMode = false;
                this.colorMode = false;
                this.renderRequested = false;
                
                // Performance tracking
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                // Raycaster for object interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Floor reference
                this.floor = null;
                
                this.init();
            }

            init() {
                try {
                    console.log('Initializing Room Designer...');
                    this.setupScene();
                    this.setupCamera();
                    this.setupRenderer();
                    this.setupLights();
                    this.createRoom();
                    this.setupControls();
                    this.setupEventListeners();
                    this.setupPerformanceMonitor();
                    
                    // Initial render to make sure everything is visible
                    this.render();
                    
                    // Hide loading screen
                    document.getElementById('loading').classList.add('hidden');
                    console.log('Room Designer initialized successfully');
                    
                    // Start render loop
                    this.animate();
                } catch (error) {
                    console.error('Failed to initialize Room Designer:', error);
                    // Still hide loading screen to show error
                    document.getElementById('loading').classList.add('hidden');
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf5e6d3);
                
                // Add fog for depth
                this.scene.fog = new THREE.Fog(0xe8d5c4, 25, 100);
            }

            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                this.camera.position.set(15, 15, 15);
                this.camera.lookAt(0, 0, 0);
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: 'high-performance'
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Enable shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.shadowMap.autoUpdate = false; // Manual shadow updates
                
                // Tone mapping
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 0.88;
                
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
            }

            setupLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xfff4e6, 0.4);
                this.scene.add(ambientLight);
                
                // Main directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffd4a0, 0.8);
                directionalLight.position.set(20, 30, 10);
                directionalLight.castShadow = true;
                
                // Shadow camera settings
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -30;
                directionalLight.shadow.camera.right = 30;
                directionalLight.shadow.camera.top = 30;
                directionalLight.shadow.camera.bottom = -30;
                
                this.scene.add(directionalLight);
            }

            createRoom() {
                // Floor
                const floorGeometry = new THREE.PlaneGeometry(40, 40);
                const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xd4b896 });
                this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
                this.floor.rotation.x = -Math.PI / 2;
                this.floor.receiveShadow = true;
                this.floor.userData = { isFloor: true };
                this.scene.add(this.floor);
                
                // Back wall
                const wallGeometry = new THREE.PlaneGeometry(40, 16);
                const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xe8dcc6 });
                
                const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
                backWall.position.set(0, 8, -20);
                backWall.receiveShadow = true;
                this.scene.add(backWall);
                
                // Left wall
                const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
                leftWall.position.set(-20, 8, 0);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.receiveShadow = true;
                this.scene.add(leftWall);
            }

            setupControls() {
                // Simple orbit controls implementation
                this.controls = {
                    isRotating: false,
                    isPanning: false,
                    previousMousePosition: { x: 0, y: 0 },
                    spherical: new THREE.Spherical(25, Math.PI / 4, Math.PI / 4),
                    target: new THREE.Vector3(0, 0, 0)
                };
                
                this.updateCameraPosition();
            }

            updateCameraPosition() {
                const position = new THREE.Vector3();
                position.setFromSpherical(this.controls.spherical);
                position.add(this.controls.target);
                
                this.camera.position.copy(position);
                this.camera.lookAt(this.controls.target);
                this.requestRender();
            }

            setupEventListeners() {
                // Mouse events
                this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.renderer.domElement.addEventListener('wheel', this.onWheel.bind(this));
                this.renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
                
                // Window events
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // UI events
                document.getElementById('resetView').addEventListener('click', this.resetView.bind(this));
                document.getElementById('deleteMode').addEventListener('click', this.toggleDeleteMode.bind(this));
                document.getElementById('colorMode').addEventListener('click', this.toggleColorMode.bind(this));
                
                // Furniture menu events
                document.querySelectorAll('.furniture-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const type = e.target.dataset.type;
                        this.startPlacingObject(type);
                    });
                });
            }

            onMouseDown(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                if (event.button === 0) { // Left mouse button
                    if (this.isPlacingObject) {
                        this.placeObject();
                    } else if (this.deleteMode) {
                        this.deleteObjectAtMouse();
                    } else {
                        // Check for object selection/dragging
                        const intersect = this.getMouseIntersection();
                        if (intersect && intersect.object.userData.isFurniture) {
                            this.selectedObject = intersect.object;
                            this.isDragging = true;
                        } else {
                            this.controls.isRotating = true;
                        }
                    }
                } else if (event.button === 2) { // Right mouse button
                    this.controls.isPanning = true;
                }
                
                this.controls.previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            onMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const deltaX = event.clientX - this.controls.previousMousePosition.x;
                const deltaY = event.clientY - this.controls.previousMousePosition.y;
                
                if (this.isDragging && this.selectedObject) {
                    this.dragObject();
                } else if (this.controls.isRotating) {
                    this.controls.spherical.theta -= deltaX * 0.005;
                    this.controls.spherical.phi += deltaY * 0.005;
                    this.controls.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.controls.spherical.phi));
                    this.updateCameraPosition();
                } else if (this.controls.isPanning) {
                    const panSpeed = 0.05;
                    const offset = new THREE.Vector3();
                    offset.setFromMatrixColumn(this.camera.matrix, 0); // x-axis
                    offset.multiplyScalar(-deltaX * panSpeed);
                    
                    const upOffset = new THREE.Vector3();
                    upOffset.setFromMatrixColumn(this.camera.matrix, 1); // y-axis
                    upOffset.multiplyScalar(deltaY * panSpeed);
                    
                    this.controls.target.add(offset).add(upOffset);
                    this.updateCameraPosition();
                }
                
                this.controls.previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            onMouseUp(event) {
                this.controls.isRotating = false;
                this.controls.isPanning = false;
                this.isDragging = false;
                this.selectedObject = null;
            }

            onWheel(event) {
                event.preventDefault();
                
                const scaleFactor = event.deltaY > 0 ? 1.1 : 0.9;
                this.controls.spherical.radius *= scaleFactor;
                this.controls.spherical.radius = Math.max(5, Math.min(100, this.controls.spherical.radius));
                
                this.updateCameraPosition();
            }

            getMouseIntersection() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                
                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.userData.isFurniture || intersects[i].object.userData.isFloor) {
                        return intersects[i];
                    }
                }
                return null;
            }

            startPlacingObject(type) {
                this.isPlacingObject = true;
                this.placingType = type;
                
                // Update UI
                document.querySelectorAll('.furniture-item').forEach(item => {
                    item.classList.toggle('selected', item.dataset.type === type);
                });
                
                this.renderer.domElement.style.cursor = 'crosshair';
            }

            placeObject() {
                const intersect = this.getMouseIntersection();
                if (!intersect || !intersect.object.userData.isFloor) return;
                
                const position = intersect.point;
                position.y = 0; // Place on floor
                
                const object = this.createFurnitureObject(this.placingType);
                object.position.copy(position);
                
                this.scene.add(object);
                this.objects.set(object.uuid, object);
                
                // Update shadows
                this.renderer.shadowMap.needsUpdate = true;
                this.requestRender();
                
                // Reset placing mode
                this.isPlacingObject = false;
                this.placingType = null;
                this.renderer.domElement.style.cursor = 'grab';
                
                // Clear selection
                document.querySelectorAll('.furniture-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }

            createFurnitureObject(type) {
                let geometry, material, object;
                
                switch (type) {
                    case 'desk':
                        // Create desk with legs
                        const deskGroup = new THREE.Group();
                        
                        // Desktop
                        const deskTop = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 0.1, 2),
                            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                        );
                        deskTop.position.y = 1.5;
                        deskTop.castShadow = true;
                        deskTop.receiveShadow = true;
                        deskGroup.add(deskTop);
                        
                        // Legs
                        for (let i = 0; i < 4; i++) {
                            const leg = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 1.5, 0.1),
                                new THREE.MeshLambertMaterial({ color: 0x654321 })
                            );
                            leg.position.x = (i % 2) ? 1.8 : -1.8;
                            leg.position.z = (i < 2) ? 0.8 : -0.8;
                            leg.position.y = 0.75;
                            leg.castShadow = true;
                            deskGroup.add(leg);
                        }
                        
                        object = deskGroup;
                        break;
                        
                    case 'chair':
                        const chairGroup = new THREE.Group();
                        
                        // Seat
                        const seat = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 0.1, 1),
                            new THREE.MeshLambertMaterial({ color: 0x4a7c59 })
                        );
                        seat.position.y = 0.9;
                        seat.castShadow = true;
                        chairGroup.add(seat);
                        
                        // Backrest
                        const backrest = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 0.1),
                            new THREE.MeshLambertMaterial({ color: 0x4a7c59 })
                        );
                        backrest.position.y = 1.4;
                        backrest.position.z = -0.45;
                        backrest.castShadow = true;
                        chairGroup.add(backrest);
                        
                        // Legs
                        for (let i = 0; i < 4; i++) {
                            const leg = new THREE.Mesh(
                                new THREE.BoxGeometry(0.05, 0.9, 0.05),
                                new THREE.MeshLambertMaterial({ color: 0x2c4a3b })
                            );
                            leg.position.x = (i % 2) ? 0.4 : -0.4;
                            leg.position.z = (i < 2) ? 0.4 : -0.4;
                            leg.position.y = 0.45;
                            leg.castShadow = true;
                            chairGroup.add(leg);
                        }
                        
                        object = chairGroup;
                        break;
                        
                    case 'bookshelf':
                        const bookshelfGroup = new THREE.Group();
                        
                        // Main structure
                        const frame = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 3, 0.8),
                            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                        );
                        frame.position.y = 1.5;
                        frame.castShadow = true;
                        bookshelfGroup.add(frame);
                        
                        // Shelves
                        for (let i = 0; i < 3; i++) {
                            const shelf = new THREE.Mesh(
                                new THREE.BoxGeometry(1.8, 0.05, 0.7),
                                new THREE.MeshLambertMaterial({ color: 0x654321 })
                            );
                            shelf.position.y = 0.5 + i * 1;
                            shelf.castShadow = true;
                            bookshelfGroup.add(shelf);
                        }
                        
                        object = bookshelfGroup;
                        break;
                        
                    case 'plant':
                        const plantGroup = new THREE.Group();
                        
                        // Pot
                        const pot = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.2, 0.4, 8),
                            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                        );
                        pot.position.y = 0.2;
                        pot.castShadow = true;
                        plantGroup.add(pot);
                        
                        // Plant leaves
                        for (let i = 0; i < 5; i++) {
                            const leaf = new THREE.Mesh(
                                new THREE.SphereGeometry(0.2, 8, 6),
                                new THREE.MeshLambertMaterial({ color: 0x228B22 })
                            );
                            leaf.position.x = (Math.random() - 0.5) * 0.6;
                            leaf.position.y = 0.4 + Math.random() * 0.8;
                            leaf.position.z = (Math.random() - 0.5) * 0.6;
                            leaf.castShadow = true;
                            plantGroup.add(leaf);
                        }
                        
                        object = plantGroup;
                        break;
                        
                    case 'lamp':
                        const lampGroup = new THREE.Group();
                        
                        // Base
                        const base = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.3, 0.1, 8),
                            new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
                        );
                        base.position.y = 0.05;
                        base.castShadow = true;
                        lampGroup.add(base);
                        
                        // Pole
                        const pole = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.02, 0.02, 2, 8),
                            new THREE.MeshLambertMaterial({ color: 0x2F4F4F })
                        );
                        pole.position.y = 1;
                        pole.castShadow = true;
                        lampGroup.add(pole);
                        
                        // Shade
                        const shade = new THREE.Mesh(
                            new THREE.ConeGeometry(0.4, 0.6, 8, 1, true),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFFFAF0,
                                side: THREE.DoubleSide
                            })
                        );
                        shade.position.y = 2.3;
                        shade.castShadow = true;
                        lampGroup.add(shade);
                        
                        object = lampGroup;
                        break;
                        
                    default:
                        // Default cube
                        object = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshLambertMaterial({ color: 0x888888 })
                        );
                        object.castShadow = true;
                        object.receiveShadow = true;
                        break;
                }
                
                object.userData = { 
                    isFurniture: true, 
                    type: type,
                    originalColor: object.material ? object.material.color.getHex() : null
                };
                
                return object;
            }

            dragObject() {
                const intersect = this.getMouseIntersection();
                if (!intersect || !intersect.object.userData.isFloor) return;
                
                const position = intersect.point;
                position.y = this.selectedObject.position.y; // Maintain height
                
                this.selectedObject.position.copy(position);
                this.requestRender();
            }

            deleteObjectAtMouse() {
                const intersect = this.getMouseIntersection();
                if (!intersect || !intersect.object.userData.isFurniture) return;
                
                let objectToRemove = intersect.object;
                
                // Find the top-level furniture object
                while (objectToRemove.parent && objectToRemove.parent !== this.scene) {
                    objectToRemove = objectToRemove.parent;
                }
                
                this.scene.remove(objectToRemove);
                this.objects.delete(objectToRemove.uuid);
                this.renderer.shadowMap.needsUpdate = true;
                this.requestRender();
            }

            toggleDeleteMode() {
                this.deleteMode = !this.deleteMode;
                document.getElementById('deleteMode').classList.toggle('active', this.deleteMode);
                this.renderer.domElement.style.cursor = this.deleteMode ? 'not-allowed' : 'grab';
            }

            toggleColorMode() {
                this.colorMode = !this.colorMode;
                document.getElementById('colorMode').classList.toggle('active', this.colorMode);
                // Color mode implementation would go here
            }

            resetView() {
                this.controls.spherical.set(25, Math.PI / 4, Math.PI / 4);
                this.controls.target.set(0, 0, 0);
                this.updateCameraPosition();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.requestRender();
            }

            setupPerformanceMonitor() {
                this.performanceMonitor = {
                    fps: document.getElementById('fps'),
                    drawCalls: document.getElementById('drawCalls'),
                    triangles: document.getElementById('triangles'),
                    memory: document.getElementById('memory')
                };
            }

            updatePerformanceStats() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime > this.lastTime + 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                    
                    // Update UI
                    this.performanceMonitor.fps.textContent = this.fps;
                    this.performanceMonitor.drawCalls.textContent = this.renderer.info.render.calls;
                    this.performanceMonitor.triangles.textContent = this.renderer.info.render.triangles;
                    
                    if (performance.memory) {
                        const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                        this.performanceMonitor.memory.textContent = memoryMB + 'MB';
                    }
                }
            }

            requestRender() {
                if (!this.renderRequested) {
                    this.renderRequested = true;
                    requestAnimationFrame(() => {
                        this.render();
                        this.renderRequested = false;
                    });
                }
            }

            render() {
                this.renderer.render(this.scene, this.camera);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                this.updatePerformanceStats();
                
                // Only render when needed (on-demand rendering)
                if (this.renderRequested || this.controls.isRotating || this.controls.isPanning || this.isDragging) {
                    this.render();
                }
            }
        }

        // Initialize the application when Three.js is loaded
        let loadAttempts = 0;
        function initApp() {
            loadAttempts++;
            
            if (typeof THREE !== 'undefined') {
                console.log('Three.js loaded, initializing app...');
                new RoomDesigner();
            } else if (loadAttempts < 50) { // Try for 5 seconds
                console.log('Waiting for Three.js to load... attempt', loadAttempts);
                setTimeout(initApp, 100);
            } else {
                console.error('Failed to load Three.js after 5 seconds');
                document.getElementById('loading').innerHTML = `
                    <div class="loading-spinner"></div>
                    <div>Failed to load 3D library. Please refresh the page.</div>
                `;
            }
        }

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>