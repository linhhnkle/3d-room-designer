{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Linh/Desktop/DeskDesigner/desk-designer-next/src/components/Scene/Room.tsx"],"sourcesContent":["import { useMemo, useRef } from 'react'\nimport { Mesh, PlaneGeometry, MeshLambertMaterial, DoubleSide } from 'three'\nimport { useStore } from '@/stores/useStore'\n\n// Pre-create geometries and materials for better performance\nconst FLOOR_GEOMETRY = new PlaneGeometry(20, 20)\nconst WALL_GEOMETRY = new PlaneGeometry(20, 8)\n\n// Shared materials to reduce memory usage\nconst createFloorMaterial = () => new MeshLambertMaterial({ \n  color: 0xd4b896,\n  side: DoubleSide \n})\n\nconst createWallMaterial = () => new MeshLambertMaterial({ \n  color: 0xe8dcc6,\n  side: DoubleSide \n})\n\nexport function Room() {\n  const floorRef = useRef<Mesh>(null)\n  const backWallRef = useRef<Mesh>(null)\n  const leftWallRef = useRef<Mesh>(null)\n  \n  const surfaces = useStore(state => state.surfaces)\n  const requestRender = useStore(state => state.requestRender)\n  \n  // Memoized materials\n  const floorMaterial = useMemo(() => createFloorMaterial(), [])\n  const wallMaterial = useMemo(() => createWallMaterial(), [])\n  \n  // Register surfaces when components mount\n  const registerSurface = (mesh: Mesh | null) => {\n    if (mesh && !surfaces.includes(mesh)) {\n      surfaces.push(mesh)\n      requestRender()\n    }\n  }\n  \n  return (\n    <group name=\"room\">\n      {/* Floor */}\n      <mesh \n        ref={(mesh) => {\n          floorRef.current = mesh\n          registerSurface(mesh)\n        }}\n        geometry={FLOOR_GEOMETRY}\n        material={floorMaterial}\n        rotation-x={-Math.PI / 2}\n        position={[0, 0, 0]}\n        receiveShadow\n        userData={{ isFloor: true, isSurface: true }}\n        name=\"floor\"\n      />\n      \n      {/* Back Wall */}\n      <mesh \n        ref={(mesh) => {\n          backWallRef.current = mesh\n          registerSurface(mesh)\n        }}\n        geometry={WALL_GEOMETRY}\n        material={wallMaterial}\n        position={[0, 4, -10]}\n        receiveShadow\n        userData={{ isWall: true }}\n        name=\"backWall\"\n      />\n      \n      {/* Left Wall */}\n      <mesh \n        ref={(mesh) => {\n          leftWallRef.current = mesh\n          registerSurface(mesh)\n        }}\n        geometry={WALL_GEOMETRY}\n        material={wallMaterial}\n        position={[-10, 4, 0]}\n        rotation-y={Math.PI / 2}\n        receiveShadow\n        userData={{ isWall: true }}\n        name=\"leftWall\"\n      />\n    </group>\n  )\n}\n\n// Separate component for room color changes to prevent unnecessary re-renders\nexport function useRoomColors() {\n  const updateFloorColor = (color: string) => {\n    // Implementation will be added when color system is integrated\n  }\n  \n  const updateWallColor = (color: string) => {\n    // Implementation will be added when color system is integrated\n  }\n  \n  return { updateFloorColor, updateWallColor }\n}"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;;;;;;AAEA,6DAA6D;AAC7D,MAAM,iBAAiB,IAAI,mKAAa,CAAC,IAAI;AAC7C,MAAM,gBAAgB,IAAI,mKAAa,CAAC,IAAI;AAE5C,0CAA0C;AAC1C,MAAM,sBAAsB,IAAM,IAAI,yKAAmB,CAAC;QACxD,OAAO;QACP,MAAM,gKAAU;IAClB;AAEA,MAAM,qBAAqB,IAAM,IAAI,yKAAmB,CAAC;QACvD,OAAO;QACP,MAAM,gKAAU;IAClB;AAEO,SAAS;;IACd,MAAM,WAAW,IAAA,uKAAM,EAAO;IAC9B,MAAM,cAAc,IAAA,uKAAM,EAAO;IACjC,MAAM,cAAc,IAAA,uKAAM,EAAO;IAEjC,MAAM,WAAW,IAAA,wIAAQ;mCAAC,CAAA,QAAS,MAAM,QAAQ;;IACjD,MAAM,gBAAgB,IAAA,wIAAQ;wCAAC,CAAA,QAAS,MAAM,aAAa;;IAE3D,qBAAqB;IACrB,MAAM,gBAAgB,IAAA,wKAAO;uCAAC,IAAM;sCAAuB,EAAE;IAC7D,MAAM,eAAe,IAAA,wKAAO;sCAAC,IAAM;qCAAsB,EAAE;IAE3D,0CAA0C;IAC1C,MAAM,kBAAkB,CAAC;QACvB,IAAI,QAAQ,CAAC,SAAS,QAAQ,CAAC,OAAO;YACpC,SAAS,IAAI,CAAC;YACd;QACF;IACF;IAEA,qBACE,6LAAC;QAAM,MAAK;;0BAEV,6LAAC;gBACC,KAAK,CAAC;oBACJ,SAAS,OAAO,GAAG;oBACnB,gBAAgB;gBAClB;gBACA,UAAU;gBACV,UAAU;gBACV,cAAY,CAAC,KAAK,EAAE,GAAG;gBACvB,UAAU;oBAAC;oBAAG;oBAAG;iBAAE;gBACnB,aAAa;gBACb,UAAU;oBAAE,SAAS;oBAAM,WAAW;gBAAK;gBAC3C,MAAK;;;;;;0BAIP,6LAAC;gBACC,KAAK,CAAC;oBACJ,YAAY,OAAO,GAAG;oBACtB,gBAAgB;gBAClB;gBACA,UAAU;gBACV,UAAU;gBACV,UAAU;oBAAC;oBAAG;oBAAG,CAAC;iBAAG;gBACrB,aAAa;gBACb,UAAU;oBAAE,QAAQ;gBAAK;gBACzB,MAAK;;;;;;0BAIP,6LAAC;gBACC,KAAK,CAAC;oBACJ,YAAY,OAAO,GAAG;oBACtB,gBAAgB;gBAClB;gBACA,UAAU;gBACV,UAAU;gBACV,UAAU;oBAAC,CAAC;oBAAI;oBAAG;iBAAE;gBACrB,cAAY,KAAK,EAAE,GAAG;gBACtB,aAAa;gBACb,UAAU;oBAAE,QAAQ;gBAAK;gBACzB,MAAK;;;;;;;;;;;;AAIb;GAnEgB;;QAKG,wIAAQ;QACH,wIAAQ;;;KANhB;AAsET,SAAS;IACd,MAAM,mBAAmB,CAAC;IACxB,+DAA+D;IACjE;IAEA,MAAM,kBAAkB,CAAC;IACvB,+DAA+D;IACjE;IAEA,OAAO;QAAE;QAAkB;IAAgB;AAC7C","debugId":null}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Linh/Desktop/DeskDesigner/desk-designer-next/src/components/Scene/Lights.tsx"],"sourcesContent":["import { useRef, useMemo } from 'react'\nimport { DirectionalLight, AmbientLight } from 'three'\nimport { useHelper } from '@react-three/drei'\nimport { DirectionalLightHelper } from 'three'\n\ninterface LightsProps {\n  timeOfDay?: 'day' | 'sunset' | 'night'\n  showHelpers?: boolean\n}\n\nexport function Lights({ timeOfDay = 'day', showHelpers = false }: LightsProps) {\n  const sunLightRef = useRef<DirectionalLight>(null)\n  const ambientLightRef = useRef<AmbientLight>(null)\n  \n  // Show light helpers in development\n  useHelper(showHelpers && sunLightRef, DirectionalLightHelper, 1)\n  \n  // Memoized light configurations for different times of day\n  const lightConfig = useMemo(() => {\n    switch (timeOfDay) {\n      case 'sunset':\n        return {\n          ambient: { color: 0xfff0d4, intensity: 0.3 },\n          sun: { \n            color: 0xffb366, \n            intensity: 0.8,\n            position: [5, 8, 10] as [number, number, number]\n          }\n        }\n      case 'night':\n        return {\n          ambient: { color: 0x404080, intensity: 0.4 },\n          sun: { \n            color: 0x8080ff, \n            intensity: 0.3,\n            position: [-5, 6, 8] as [number, number, number]\n          }\n        }\n      default: // day\n        return {\n          ambient: { color: 0xfff4e6, intensity: 0.25 },\n          sun: { \n            color: 0xffd4a0, \n            intensity: 0.6,\n            position: [10, 15, 8] as [number, number, number]\n          }\n        }\n    }\n  }, [timeOfDay])\n  \n  return (\n    <group name=\"lights\">\n      {/* Ambient Light */}\n      <ambientLight\n        ref={ambientLightRef}\n        color={lightConfig.ambient.color}\n        intensity={lightConfig.ambient.intensity}\n      />\n      \n      {/* Directional Light (Sun) */}\n      <directionalLight\n        ref={sunLightRef}\n        color={lightConfig.sun.color}\n        intensity={lightConfig.sun.intensity}\n        position={lightConfig.sun.position}\n        // castShadow\n        shadow-mapSize-width={1024}\n        shadow-mapSize-height={1024}\n        shadow-camera-near={0.1}\n        shadow-camera-far={50}\n        shadow-camera-left={-15}\n        shadow-camera-right={15}\n        shadow-camera-top={15}\n        shadow-camera-bottom={-15}\n        shadow-radius={10}\n        shadow-blurSamples={8}\n      />\n    </group>\n  )\n}\n\n// Performance-optimized shadow settings\nexport const SHADOW_CONFIG = {\n  enabled: true,\n  type: 'PCFSoftShadowMap' as const,\n  autoUpdate: false, // Manual shadow updates for better performance\n}"],"names":[],"mappings":";;;;;;;AAAA;AAEA;AACA;;;;;;AAOO,SAAS,OAAO,KAAuD;QAAvD,EAAE,YAAY,KAAK,EAAE,cAAc,KAAK,EAAe,GAAvD;;IACrB,MAAM,cAAc,IAAA,uKAAM,EAAmB;IAC7C,MAAM,kBAAkB,IAAA,uKAAM,EAAe;IAE7C,oCAAoC;IACpC,IAAA,0KAAS,EAAC,eAAe,aAAa,4KAAsB,EAAE;IAE9D,2DAA2D;IAC3D,MAAM,cAAc,IAAA,wKAAO;uCAAC;YAC1B,OAAQ;gBACN,KAAK;oBACH,OAAO;wBACL,SAAS;4BAAE,OAAO;4BAAU,WAAW;wBAAI;wBAC3C,KAAK;4BACH,OAAO;4BACP,WAAW;4BACX,UAAU;gCAAC;gCAAG;gCAAG;6BAAG;wBACtB;oBACF;gBACF,KAAK;oBACH,OAAO;wBACL,SAAS;4BAAE,OAAO;4BAAU,WAAW;wBAAI;wBAC3C,KAAK;4BACH,OAAO;4BACP,WAAW;4BACX,UAAU;gCAAC,CAAC;gCAAG;gCAAG;6BAAE;wBACtB;oBACF;gBACF;oBACE,OAAO;wBACL,SAAS;4BAAE,OAAO;4BAAU,WAAW;wBAAK;wBAC5C,KAAK;4BACH,OAAO;4BACP,WAAW;4BACX,UAAU;gCAAC;gCAAI;gCAAI;6BAAE;wBACvB;oBACF;YACJ;QACF;sCAAG;QAAC;KAAU;IAEd,qBACE,6LAAC;QAAM,MAAK;;0BAEV,6LAAC;gBACC,KAAK;gBACL,OAAO,YAAY,OAAO,CAAC,KAAK;gBAChC,WAAW,YAAY,OAAO,CAAC,SAAS;;;;;;0BAI1C,6LAAC;gBACC,KAAK;gBACL,OAAO,YAAY,GAAG,CAAC,KAAK;gBAC5B,WAAW,YAAY,GAAG,CAAC,SAAS;gBACpC,UAAU,YAAY,GAAG,CAAC,QAAQ;gBAClC,aAAa;gBACb,wBAAsB;gBACtB,yBAAuB;gBACvB,sBAAoB;gBACpB,qBAAmB;gBACnB,sBAAoB,CAAC;gBACrB,uBAAqB;gBACrB,qBAAmB;gBACnB,wBAAsB,CAAC;gBACvB,iBAAe;gBACf,sBAAoB;;;;;;;;;;;;AAI5B;GArEgB;;QAKd,0KAAS;;;KALK;AAwET,MAAM,gBAAgB;IAC3B,SAAS;IACT,MAAM;IACN,YAAY;AACd","debugId":null}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Linh/Desktop/DeskDesigner/desk-designer-next/src/components/Objects/ObjectLoader.tsx"],"sourcesContent":["import { Suspense, useMemo, useCallback, useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport * as THREE from 'three'\nimport { Object3D, Vector3, Box3, Mesh, MeshLambertMaterial } from 'three'\nimport { useStore } from '@/stores/useStore'\nimport { GLTF } from 'three/examples/jsm/loaders/GLTFLoader'\n\n// Model path mapping\nconst MODEL_PATHS: Record<string, string> = {\n  desk: '/Furniture/desk1.glb',\n  chair: '/Furniture/chair.glb',\n  monitor: '/Furniture/monitor.glb',\n  plant: '/Furniture/plant1.glb'\n}\n\n// Fallback geometries for failed models\nconst FALLBACK_GEOMETRIES = {\n  desk: { type: 'box', args: [4, 1.2, 2], color: 0x8B4513 },\n  chair: { type: 'box', args: [1.2, 2, 1.2], color: 0x654321 },\n  monitor: { type: 'box', args: [2, 1.5, 0.2], color: 0x2a2a2a },\n  plant: { type: 'sphere', args: [0.8, 8, 6], color: 0x4a7c59 }\n}\n\n// Scale configurations\nconst OBJECT_SCALES: Record<string, number> = {\n  desk: 4,\n  chair: 4,\n  monitor: 3,\n  plant: 3,\n  sofa: 5,\n  lamp: 2,\n  laptop: 1.5\n}\n\ninterface GLTFModelProps {\n  type: string\n  position: Vector3\n  onLoad?: (object: Object3D) => void\n}\n\n// Individual GLTF model component with error boundary\nfunction GLTFModel({ type, position, onLoad }: GLTFModelProps) {\n  const modelRef = useRef<Object3D>(null)\n  const modelPath = MODEL_PATHS[type]\n  \n  try {\n    const { scene } = useGLTF(modelPath) as GLTF\n    \n    // Clone the scene to allow multiple instances\n    const clonedScene = useMemo(() => {\n      const clone = scene.clone()\n      \n      // Set scale\n      const scale = OBJECT_SCALES[type] || 1\n      clone.scale.setScalar(scale)\n      \n      // Set position\n      clone.position.copy(position)\n      \n      // Configure for shadows\n      clone.traverse((child) => {\n        if (child instanceof Mesh) {\n          child.castShadow = true\n          child.receiveShadow = true\n          \n          // Clone materials to avoid sharing\n          if (child.material) {\n            child.material = child.material.clone()\n          }\n        }\n      })\n      \n      // Set metadata\n      clone.userData = {\n        type,\n        isModel: true,\n        isSurface: ['desk', 'chair', 'sofa'].includes(type)\n      }\n      \n      return clone\n    }, [scene, type, position])\n    \n    // Notify parent when loaded\n    useMemo(() => {\n      if (onLoad && clonedScene) {\n        onLoad(clonedScene)\n      }\n    }, [clonedScene, onLoad])\n    \n    return <primitive ref={modelRef} object={clonedScene} />\n    \n  } catch (error) {\n    console.warn(`Failed to load model ${type}, using fallback`)\n    return <FallbackModel type={type} position={position} onLoad={onLoad} />\n  }\n}\n\n// Fallback component for failed model loads\nfunction FallbackModel({ type, position, onLoad }: GLTFModelProps) {\n  const meshRef = useRef<Mesh>(null)\n  const fallback = FALLBACK_GEOMETRIES[type] || FALLBACK_GEOMETRIES.desk\n  \n  const mesh = useMemo(() => {\n    let geometry\n    \n    switch (fallback.type) {\n      case 'sphere':\n        geometry = new THREE.SphereGeometry(...fallback.args)\n        break\n      default:\n        geometry = new THREE.BoxGeometry(...fallback.args)\n    }\n    \n    const material = new MeshLambertMaterial({ color: fallback.color })\n    const mesh = new Mesh(geometry, material)\n    \n    mesh.position.copy(position)\n    mesh.castShadow = true\n    mesh.receiveShadow = true\n    \n    mesh.userData = {\n      type,\n      isModel: false,\n      isSurface: ['desk', 'chair', 'sofa'].includes(type)\n    }\n    \n    return mesh\n  }, [type, position, fallback])\n  \n  useMemo(() => {\n    if (onLoad && mesh) {\n      onLoad(mesh)\n    }\n  }, [mesh, onLoad])\n  \n  return <primitive ref={meshRef} object={mesh} />\n}\n\n// Loading placeholder component\nfunction LoadingPlaceholder({ position }: { position: Vector3 }) {\n  return (\n    <mesh position={position}>\n      <boxGeometry args={[1, 1, 1]} />\n      <meshBasicMaterial color={0x888888} transparent opacity={0.3} />\n    </mesh>\n  )\n}\n\n// Main object loader with suspense and error handling\ninterface ObjectLoaderProps {\n  type: string\n  position?: Vector3\n  id?: string\n}\n\nexport function ObjectLoader({ type, position = new Vector3(), id }: ObjectLoaderProps) {\n  const addObject = useStore(state => state.addObject)\n  const selectObject = useStore(state => state.selectObject)\n  const surfaces = useStore(state => state.surfaces)\n  \n  const handleObjectLoad = useCallback((object: Object3D) => {\n    const objectData = {\n      id: id || `${type}-${Date.now()}`,\n      object,\n      type,\n      position: position.clone(),\n      scale: new Vector3(1, 1, 1),\n      rotation: 0\n    }\n    \n    // Add to store\n    addObject(objectData)\n    \n    // Add to surfaces if applicable\n    if (object.userData.isSurface) {\n      surfaces.push(object)\n    }\n    \n    // Auto-select newly added objects\n    selectObject(objectData)\n  }, [type, position, id, addObject, selectObject, surfaces])\n  \n  return (\n    <Suspense fallback={<LoadingPlaceholder position={position} />}>\n      <GLTFModel \n        type={type} \n        position={position} \n        onLoad={handleObjectLoad}\n      />\n    </Suspense>\n  )\n}\n\n// Preload all models for better performance\nexport function preloadModels() {\n  Object.values(MODEL_PATHS).forEach(path => {\n    useGLTF.preload(path)\n  })\n}\n\n// Cleanup function to dispose of unused models\nuseGLTF.clear = () => {\n  Object.values(MODEL_PATHS).forEach(path => {\n    useGLTF.clear(path)\n  })\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Linh/Desktop/DeskDesigner/desk-designer-next/src/components/Canvas3D.tsx"],"sourcesContent":["'use client'\n\nimport { Canvas } from '@react-three/fiber'\nimport { Suspense, useEffect } from 'react'\nimport { PCFSoftShadowMap, SRGBColorSpace, ACESFilmicToneMapping } from 'three'\nimport { Stats, AdaptiveDpr, AdaptiveEvents } from '@react-three/drei'\nimport { Room } from './Scene/Room'\nimport { Lights, SHADOW_CONFIG } from './Scene/Lights'\nimport { Camera } from './Scene/Camera'\nimport { ObjectLoader, preloadModels } from './Objects/ObjectLoader'\nimport { useStore } from '@/stores/useStore'\nimport { useObjectSelection } from '@/hooks/useObjectSelection'\nimport { useDragAndDrop } from '@/hooks/useDragAndDrop'\nimport { usePerformanceMonitor, useRenderOnDemand } from '@/hooks/usePerformance'\n\n// Scene content component\nfunction SceneContent() {\n  const objects = useStore(state => state.objects)\n  \n  // Remove performance monitoring hooks for now to reduce overhead\n  // const { handleSelect, handleHover } = useObjectSelection()\n  // const { setupDragListeners } = useDragAndDrop()\n  // const fps = usePerformanceMonitor()\n  // const { renderRequested } = useRenderOnDemand()\n  \n  // Setup interaction listeners\n  // useEffect(() => {\n  //   const cleanup = setupDragListeners()\n  //   return cleanup\n  // }, [setupDragListeners])\n  \n  return (\n    <>\n      {/* Core Scene */}\n      <Camera />\n      <Lights timeOfDay=\"day\" />\n      <Room />\n      \n      {/* Dynamic Objects */}\n      {objects.map((obj) => (\n        <primitive \n          key={obj.id} \n          object={obj.object} \n          position={obj.position}\n          scale={obj.scale}\n          rotation-y={obj.rotation}\n        />\n      ))}\n      \n      {/* Performance Stats (Development) */}\n      {process.env.NODE_ENV === 'development' && (\n        <Stats showPanel={0} className=\"stats\" />\n      )}\n    </>\n  )\n}\n\n// Loading fallback\nfunction CanvasLoader() {\n  return (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gradient-to-br from-[#f5e6d3] to-[#e8d5c4]\">\n      <div className=\"text-[#8b6f47] font-medium\">Loading 3D Scene...</div>\n    </div>\n  )\n}\n\n// Main Canvas component\nexport function Canvas3D() {\n  const renderRequested = useStore(state => state.renderRequested)\n  \n  // Preload models on component mount\n  useEffect(() => {\n    preloadModels()\n  }, [])\n  \n  return (\n    <div className=\"absolute inset-0\">\n      <Canvas\n        // Performance optimizations\n        dpr={1} // Fixed pixel ratio for consistent performance\n        frameloop=\"demand\" // Always use demand mode for better performance\n        flat // Disable linear tone mapping for better performance\n        legacy={false} // Use modern WebGL features\n        \n        // Canvas configuration\n        camera={false} // We'll use our custom camera\n        shadows={false}\n        \n        // WebGL settings\n        gl={{\n          powerPreference: 'high-performance',\n          antialias: false,\n          alpha: false,\n          stencil: false,\n          depth: true,\n          logarithmicDepthBuffer: false,\n          outputColorSpace: SRGBColorSpace,\n          toneMapping: ACESFilmicToneMapping,\n          toneMappingExposure: 0.88,\n          shadowMap: {\n            enabled: true,\n            type: PCFSoftShadowMap,\n            autoUpdate: false\n          }\n        }}\n        \n        // Container styling\n        className=\"outline-none\"\n        style={{ \n          touchAction: 'none',\n          WebkitTouchCallout: 'none',\n          WebkitUserSelect: 'none',\n          userSelect: 'none'\n        }}\n      >\n        {/* Performance Helpers */}\n        <AdaptiveEvents />\n        \n        {/* Scene Content with Suspense */}\n        <Suspense fallback={null}>\n          <SceneContent />\n        </Suspense>\n        \n        {/* Fog for depth */}\n        <fog attach=\"fog\" args={[0xe8d5c4, 25, 50]} />\n      </Canvas>\n      \n      {/* Canvas Loader Overlay */}\n      <Suspense fallback={<CanvasLoader />}>\n        <div /> {/* Empty div to trigger Suspense */}\n      </Suspense>\n    </div>\n  )\n}"],"names":[],"mappings":";;;;AAkDO;;AAhDP;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAVA;;;;;;;;;;AAeA,0BAA0B;AAC1B,SAAS;;IACP,MAAM,UAAU,IAAA,wIAAQ;0CAAC,CAAA,QAAS,MAAM,OAAO;;IAE/C,iEAAiE;IACjE,6DAA6D;IAC7D,kDAAkD;IAClD,sCAAsC;IACtC,kDAAkD;IAElD,8BAA8B;IAC9B,oBAAoB;IACpB,yCAAyC;IACzC,mBAAmB;IACnB,2BAA2B;IAE3B,qBACE;;0BAEE,6LAAC,kJAAM;;;;;0BACP,6LAAC,kJAAM;gBAAC,WAAU;;;;;;0BAClB,6LAAC,8IAAI;;;;;YAGJ,QAAQ,GAAG,CAAC,CAAC,oBACZ,6LAAC;oBAEC,QAAQ,IAAI,MAAM;oBAClB,UAAU,IAAI,QAAQ;oBACtB,OAAO,IAAI,KAAK;oBAChB,cAAY,IAAI,QAAQ;mBAJnB,IAAI,EAAE;;;;;YASd,oDAAyB,+BACxB,6LAAC,qKAAK;gBAAC,WAAW;gBAAG,WAAU;;;;;;;;AAIvC;GAvCS;;QACS,wIAAQ;;;KADjB;AAyCT,mBAAmB;AACnB,SAAS;IACP,qBACE,6LAAC;QAAI,WAAU;kBACb,cAAA,6LAAC;YAAI,WAAU;sBAA6B;;;;;;;;;;;AAGlD;MANS;AASF,SAAS;;IACd,MAAM,kBAAkB,IAAA,wIAAQ;8CAAC,CAAA,QAAS,MAAM,eAAe;;IAE/D,oCAAoC;IACpC,IAAA,0KAAS;8BAAC;YACR,IAAA,iKAAa;QACf;6BAAG,EAAE;IAEL,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC,gNAAM;gBACL,4BAA4B;gBAC5B,KAAK;gBACL,WAAU;gBACV,IAAI;gBACJ,QAAQ;gBAER,uBAAuB;gBACvB,QAAQ;gBACR,SAAS;gBAET,iBAAiB;gBACjB,IAAI;oBACF,iBAAiB;oBACjB,WAAW;oBACX,OAAO;oBACP,SAAS;oBACT,OAAO;oBACP,wBAAwB;oBACxB,kBAAkB,oKAAc;oBAChC,aAAa,2KAAqB;oBAClC,qBAAqB;oBACrB,WAAW;wBACT,SAAS;wBACT,MAAM,sKAAgB;wBACtB,YAAY;oBACd;gBACF;gBAEA,oBAAoB;gBACpB,WAAU;gBACV,OAAO;oBACL,aAAa;oBACb,oBAAoB;oBACpB,kBAAkB;oBAClB,YAAY;gBACd;;kCAGA,6LAAC,uLAAc;;;;;kCAGf,6LAAC,yKAAQ;wBAAC,UAAU;kCAClB,cAAA,6LAAC;;;;;;;;;;kCAIH,6LAAC;wBAAI,QAAO;wBAAM,MAAM;4BAAC;4BAAU;4BAAI;yBAAG;;;;;;;;;;;;0BAI5C,6LAAC,yKAAQ;gBAAC,wBAAU,6LAAC;;;;;;kCACnB,6LAAC;;;;;oBAAM;;;;;;;;;;;;;AAIf;IAlEgB;;QACU,wIAAQ;;;MADlB","debugId":null}}]
}